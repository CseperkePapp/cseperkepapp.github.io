const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; } resize(); let particles = []; const particleCount = 150; const mouse = { x: canvas.width / 2, y: canvas.height / 2 }; const colors = [ 'rgba(255, 215, 0, 0.8)','rgba(255, 237, 78, 0.7)','rgba(74, 138, 160, 0.8)','rgba(42, 74, 106, 0.7)','rgba(255, 140, 66, 0.8)','rgba(255, 107, 26, 0.7)','rgba(138, 76, 160, 0.6)','rgba(200, 200, 255, 0.5)'];
class Particle{ constructor(){ this.x = Math.random()*canvas.width; this.y = Math.random()*canvas.height; this.vx = (Math.random()-0.5)*0.8; this.vy = (Math.random()-0.5)*0.8; this.size = Math.random()*3+1; this.color = colors[Math.floor(Math.random()*colors.length)]; this.life = 1; this.decay = Math.random()*0.02 + 0.005; this.originalSize = this.size; this.trail = []; this.trailLength = Math.floor(Math.random()*20)+10; }
 update(){ const dx = mouse.x - this.x; const dy = mouse.y - this.y; const distance = Math.sqrt(dx*dx + dy*dy); if (distance < 200){ const force = (200-distance)/200*0.3; this.vx += (dx/distance)*force*0.1; this.vy += (dy/distance)*force*0.1; }
 this.vx += Math.sin(Date.now()*0.0005 + this.x*0.01)*0.05; this.vy += Math.cos(Date.now()*0.0005 + this.y*0.01)*0.05; this.x += this.vx; this.y += this.vy; this.trail.push({ x: this.x, y: this.y, life: 1 }); if (this.trail.length > this.trailLength) this.trail.shift(); this.trail.forEach((point,index)=>{ point.life = index/this.trail.length; }); this.vx *= 0.98; this.vy *= 0.98; this.life -= this.decay; this.size = this.originalSize * this.life; if (this.x < 0) this.x = canvas.width; if (this.x > canvas.width) this.x = 0; if (this.y < 0) this.y = canvas.height; if (this.y > canvas.height) this.y = 0; if (this.life <= 0){ this.x = Math.random()*canvas.width; this.y = Math.random()*canvas.height; this.life = 1; this.size = this.originalSize; this.trail = []; this.color = colors[Math.floor(Math.random()*colors.length)]; } }
 draw(){ ctx.save(); if (this.trail.length > 1){ ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i=1;i<this.trail.length;i++){ ctx.lineTo(this.trail[i].x, this.trail[i].y); } ctx.strokeStyle = this.color.replace(/[,)]\)$/g, (this.life*0.3)+')'); ctx.lineWidth = this.size*0.5; ctx.lineCap = 'round'; ctx.stroke(); }
 const gradient = ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.size*2); gradient.addColorStop(0,this.color); gradient.addColorStop(0.5,this.color.replace(/[,)]\)$/g, (this.life*0.3)+')')); gradient.addColorStop(1,'transparent'); ctx.beginPath(); ctx.arc(this.x,this.y,this.size*2,0,Math.PI*2); ctx.fillStyle = gradient; ctx.fill(); ctx.beginPath(); ctx.arc(this.x,this.y,this.size*0.5,0,Math.PI*2); ctx.fillStyle = this.color.replace(/[,)]\)$/g, (this.life*0.9)+')'); ctx.fill(); ctx.restore(); } }
for (let i=0;i<particleCount;i++) particles.push(new Particle()); function animate(){ ctx.fillStyle = 'rgba(10,10,26,0.1)'; ctx.fillRect(0,0,canvas.width,canvas.height); particles.forEach(p=>{ p.update(); p.draw(); }); for (let i=0;i<particles.length;i++){ for (let j=i+1;j<particles.length;j++){ const dx = particles[i].x - particles[j].x; const dy = particles[i].y - particles[j].y; const distance = Math.sqrt(dx*dx + dy*dy); if (distance < 100){ ctx.beginPath(); ctx.moveTo(particles[i].x, particles[i].y); ctx.lineTo(particles[j].x, particles[j].y); ctx.strokeStyle = `rgba(255, 215, 0, ${(1 - distance/100) * 0.2})`; ctx.lineWidth = 0.5; ctx.stroke(); } } } requestAnimationFrame(animate); }
canvas.addEventListener('mousemove',(e)=>{ mouse.x = e.clientX; mouse.y = e.clientY; }); canvas.addEventListener('touchmove',(e)=>{ e.preventDefault(); mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; }); window.addEventListener('resize',()=>{ resize(); }); animate();